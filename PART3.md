### Services in Angular

Defining data is not the component's job. With the data inside the component, it can't easily be shared with other components and views.
We will refactor this job data into a single service that provides the data that we need. 

#### Build a Service

- Create a file in the `app` folder called `job.service.ts`.
- Create a class called `HeroService`
- We'll include the `Injectable` function, and decorate our class with it. 
 
		import {Injectable} from 'angular2/core';
		
		@Injectable()
		export class HeroService {
		}

- Add a `getJobs()` function to our class

		@Injectable()
		export class HeroService {
		  getJobs() {
		  }
		}
		
Let us pause to point out that the consumer of our service won't know how the service gets the data, nor should it care. Our `JobService` could get the data from a web service or local storage or from a mock data source. That's the beauty of removing data access from the component. We can modify the implementation as needed for whatever reason without touching any of the components.

We already have mock Job data sitting in the `JobListComponent`. It doesn't belong there, and it doesn't belong inside `HeroService` either. We'll move the data to its own `.json` file. In a production environment, this json response may have been generated by your server so it's a good analog. 

- In `app/` create a new file, `jobs.json`
- Let's copy the array of data from `JobListComponent`, and create a valid json object with it. Like this:

		{
		  "jobs": [
		    {
		      "title": "Web Developer",
		      "company": "MyCompany, Inc.",
		      "startDate": "2016-01-01T00:00:00+00:00",
		      "endDate": null
		    },
		    {
		      "title": "Front End Developer",
		      "company": "Big Co.",
		      "startDate": "2015-03-01T00:00:00+00:00",
		      "endDate": "2016-01-01T00:00:00+00:00"
		    }
		  ]
		}

##### Use Angular's `http` library for retrieving the data

SystemJS will not load the `http` bundle implicitly, and we will need to add that to our HTML [<sup>1</sup>](https://stackoverflow.com/questions/34401354/angular2-beta-bootstrapping-http-providers-unexpected-token). Other module loaders, like WebPack, could have done this for us automagically. 
At the bottom of the list of scripts in index, add 

	<script src="node_modules/angular2/bundles/http.dev.js"></script>
		
Next, our app component will require an import of `HTTP_PROVIDERS`. Why is that? `HTTP_PROVIDERS` provides a basic set of injectables to use the Http service anywhere in our application. The HTTP_PROVIDERS should be included either in a component's injector, or in the root injector when bootstrapping an application. Learn more about [HTTP_PROVIDER](https://angular.io/docs/ts/latest/api/http/HTTP_PROVIDERS-let.html) in Angular's docs. 
In main.ts, add 
		
	import {HTTP_PROVIDERS} from 'angular2/http';
	... 
	bootstrap(AppComponent, [HTTP_PROVIDERS]);
		
Use `http` in `jobs.service` in order to pull the data asynchronously. So in `jobs.service.ts` we need to

	import { Http, Response } from 'angular2/http';

Why are we importing it here? Didn't we already import `HTTP_PROVIDER`?? Yes we did, but the provider is not the actual `http` class. We are importing it in our service because here is where we will be requesting the data. Learn more about [http](https://angular.io/docs/ts/latest/api/http/Http-class.html) in Angular's docs. 

Additionally we'll be using a function called `map`, which we'll import as well.

	import 'rxjs/add/operator/map';
		
In our service's constructor we'll pass the instance of `http`. 
			
	constructor(public http: Http) {}
			
Why are we using `public` here? By making it public, it means that we are exposing `http` elsewhere in our service, not just within the constructor's scope. We'll be extracting out the implementation into a method, which can be called from the consumer's side. 

Now create a method under the constructor called `getJobs()`. We will be returning a call to `http` and using the `map` function on the Response.

	getJobs() {
	
	}

And let's use our service's instance of `http` to make a `GET` request. 

	getJobs() {
		return this.http.get('/app/jobs.json');
	}

This is where `map` comes in. You use map to transform a collection of items into a collection of different items. Here, we're transforming the response into a JSON collection. 
		
	getJobs() {
    return this.http.get('/app/jobs.json')
      .map((res: Response) => { return res.json(); });
	}
			
Now STOP. We're returning the result from our `http.get` call. But what is the result? `http` requests return `Observables` which will emit a single `Response` when a response is received.
WHOA OBSERVABLES. Its a new word, and they are quite different from Promises. The main benefit is that Observables work much better through a subscription model that is cancellable, giving the developer more control over the action. Similarly, you can retry an observable again and again, where with Promises you need to have access to the function that called it because once resolved Promises cannot be reused. For better illustration to this, you might watch ["RxJS Observables vs Promises" on Egghead.io](https://egghead.io/lessons/rxjs-rxjs-observables-vs-promises).

Suffice it to say that we will have to handle the Observable a little differently than we would have with Promises in Angular 1. 

#### Update job-list.component to use the service

Now, let's use this service in our `job-list.component.ts` file. Import the service at the top of the file. 

	import { JobsService } from './jobs.service';
		
and include the JobService in our constructor

	constructor(private _jobsService:JobsService) {}

We must now register the `JobsService` as a provider; it is this way that the _injector_ knows how to create a `JobsService` instance. Do that by adding a providers array property to the bottom of the @Component configuration object.
            
	@Component({
	  ...
	  providers: [JobsService]
	})

> NOTE: Child components will generally not repeat its parent's providers array! Why? Because that tells Angular to create a new instance of the Service at the ChildComponent level. In most cases, the ChildComponent doesn't want its own service instance; it wants its parent's service instance. Adding the providers array creates a new service instance that shadows the parent instance.

Now we just need to call our service. But where? In a constructor? We do not! Best practices teach us to keep complex logic out of the constructor. The constructor is for simple initializations like wiring constructor parameters to properties. **It's not for heavy lifting**. 

If not the constructor, something has to call `getJobs()`. Angular will call it if we implement the Angular `ngOnInit` _Lifecycle Hook_. Angular offers a number of interfaces for tapping into critical moments in the component lifecycle: at creation, after each change, and at its eventual destruction.

We write an `ngOnInit` method with our initialization logic inside and leave it to Angular to call it at the right time. The `ngOnInit` interface needs to be imported as well.

	import { OnInit } from 'angular2/core';

Then implement it on our JobListComponent class

	export class JobListComponent implements OnInit { ... }
		
And finally, we write our method inside the class

	ngOnInit() {
	}
	
So, what was this for again? It was to use the  `getJobs` method on the `JobsService` to get our data. So in `ngOnInit` we will do so

	ngOnInit() {
		this._jobsService.getJobs()
      .subscribe(res => this.jobs = res.jobs);
	}

What, what is that `subscribe()` call? Observables will emit an object once complete, and subscribing to that will allow us to react to whatever was emitted (thus, the name ReactiveX.js). So in this call we are subscribing to the observable that our service returns, handing the answer off to our view by binding the result to the `jobs` property of the class instance.

And just like that, our data is now dynamically pulled in once the app initializes. 

![](http://i.imgur.com/iCNrX0S.gifv)

This has been a great example of how to keep components small and modular, as well as separating our concerns into maintainable pieces. 